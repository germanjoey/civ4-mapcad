A: alpha for alpha
B: required for beta

Big Ticket TODO:

    - B: method of assigning a fixed set of resources/weights to a mask, one at a time - allocation function
    - B: is there a good way of applying a mask to a bunch of starts? a "apply_mask_to_starts" command or something like that? 
    - B: balance commands
    - A: tutorials
    - A: test difference/merge
    - B: tests

Medium Ticket TODO:

    - A: decide how to handle width/height of group vs individual layers
        - should groups have a fixed size? should size be based on background?
        - two different merge modes?
    - B: apply_shape_to_mask
    - B: new_mask_from_magic_wand
    - A: dump map info
    - A: dump weight to table
    - B: redo shitty nested error handling in e.g. Param::Parser with real exceptions ala Try::Tiny
    - A: organize module methods

Small Ticket TODO:
    - new wrap/crop commands for group/layer
    - merge layer command
        - both layers must be in the same group
    - A: make set_priority interface have the highest numbers on top
    
Group Stuff
    - when a group is created, wrap can be set or unset, and dimensions are set
        - import_group sets dimensions and wrap automatically from the base_layer
        - for new_group:
            - use flags at creation to set --noWrapX and --noWrapY
            - &set_group_wrap --wrapX --wrapY
                - sets cooresponding wrap on each layer
                - layers all have the same wrap property as the group for that dimension
            - &expand_layer_canvas
            - &crop_group
            - expand_group_canvas
                - does nothing to the layers
            - when new layer is added
                - wrap is set to be the same as the layer
            - whenever layer is added:
                - group is expanded if dimension exceeds
                - a warning is displayed
            - whenever a layer is resized:
                - error if expanded beyond group size
            - whenever a layer is moved:
                - nothing happens
            - when two layers are merged:
                - wrap boundaries are determined based on group dimensions
                - if wrap occurs, width/height of result layer = width/height of group
            - when group is flattened
                - we just flatten each two pair of layers
                
Five tutorials
    - index page
    - first tutorial (setup + intro)
    - starting the banana - masks/weights/terrain
    - intro to layers/groups (a break from the banana)
    - finishing up the banana
    - balance
    
land allocation method
1.) find starts
2.) for each start:
    - calculate distance between them to calculate average distance
    - assign tiles
        - 1.) generate a soft circle mask around them based on average distance somehow
        - 2.) calculate a "path distance" to each tile
            - breadth-first search, like novice's tool
            - essentially allocates one tile at a time per civ based on closest distance
            - e.g. coast tiles have a distance of "2", hills 1.4, or something
            - need not a*, but djiksra's algorithm probably
                - needed for bfc assignment anyways
            
        - 3.) bfc assignment
            - need evaluate_bfc_quality function
            - tiles are allocated in chunks
            - if this is good enough, this will be all we need!
            - pseudocode below
            
        - 5.) weighted average of all 4 approaches, if BFC approach is weakish
        
        
BFC assignment method for land allocation pseudocode:
    (all matrices here are 2D arrays the same size as the map)

    bfc_allocation (map) {
    
        total_allocation = new blank matrix
        foreach tile in map
            foreach civ
                total_allocation.tile.civ = 0
                tile's distance from each capital is cached
            

        # each local_allocation is one guess on what the map would look like this were an always_peace game            
        for 1..1000 # or 100 or 10000 or whatever
            local_allocation = bfc_allocation_single_step(map)
            
            foreach tile in local_allocation
                foreach civ
                    total_allocation.tile.civ += local_allocation.tile.civ
                    
        # take our 1000 guesses to get a true estimate on how likely it is a particular civ will gain a particular tile
        # in later revisions, later passes should get weighted more highly because they should be influenced by good results from previous passes
        foreach tile in total_allocation
            foreach civ
                total_allocation.tile.civ /= 1000
            
        return total_allocation
    }
    
    bfc_allocation_single_step (map) {
        local_allocation = new blank matrix 
        allocate capital BFCs in map
        
        num_allocated = num civs
        while (1) {
            if num_allocated == 0
                break 
                
            num_allocated = 0
            
            # looping through civs like this is fine for the first revision, but eventually this should be a priority queue based on
            # "settling power", which is the result of the sum of a civ's bfc-power, which new cities get added to on a time delay
            foreach civ
                potential_sites = all tiles between 3 and 6 away of any of this civ's cities
                filter potential_sites of any tiles that are less than 3 away of any other civ's cities
                
                foreach tile in potential_sites
                    calculate bfc quality of a city centered on this tile based purely on tile yields
                        - first-ring should be more valuable than second ring
                        - seafood should be rated under equivalent yield of land-tile
                        - should have flags for considering yields of copper/iron/horses
                        - should have flags for considering plantations and jungle-gems
                    
                if potential_sites == 0
                    continue
                    
                foreach bfc 
                    now factor in strategic concerns:
                        - copper's concern increases exponentially for each city after the first, then drops to 0 once copper is   
                          captured
                        - horse's concern increases exponentially for each city after the second, then drops to 0 once horse is 
                          captured
                        - iron's concern increases exponentially for each city after the eighth, then drops to 0 once iron is captured
                        - marble and stone have a high but linearly increasing concern for each city after the 5t, then drop to 0 
                          once they are captured. stone's concern drops off exponentially after the 10th city.
                        - luxuries should be considered whether they are ancient or classical and how many cities have so far
                          been settled
                        - cities closer to the capital are valued more highly than those further from it
                        - cities settled towards closer rivals are valued more highly than those settled away
                            - do we do this based on capitals or what rivals have settled already? not sure. later way is more
                              computationally intensive for sure.
                        - cities on hills are valued more highly if they are closer to rivals
                        - eventually, for later revisions, sites from previous passes that were found to be good should be weighted higher
                        
                # now we have a score for each potential site
                
                pick the top 10 sites
                
                total = 0
                foreach site 
                    total += (site's score)^2
                
                foreach site
                    settling_probability = (site's score)^2 / total
                    
                # now we have a settling probability for each site
                pick a random site based on their weight - our "blue circle"
                
                allocate that BFC for that civ onto local_allocation.
                (if the bfc overlaps with the bfc from another civ, these overlapped tiles should be allocated to both)
                num_allocated ++
                
        return local_allocation
    }